/**
 * src/lib/tasks/invoice-hook.ts
 *
 * Auto-generate and send a Wave invoice when a website_deployment task
 * transitions to "deployed". Fires as a background side-effect inside
 * the transition route — non-blocking (errors are logged, not surfaced to caller).
 *
 * Only triggers when ALL of:
 *   1. task.taskType === 'website_deployment'
 *   2. toStatus === 'deployed'
 *   3. client has a valid waveCustomerId
 *   4. Wave SEO product ID is configured
 *   5. No invoice already exists for this task (idempotency check)
 */

import { prisma } from '@/lib/db'
import { ensureWaveCustomer } from '@/lib/wave/sync'
import { createInvoice, sendInvoice } from '@/lib/wave/invoices'
import { getSeoProductId } from '@/lib/wave/product-id'
import { addDays, format, startOfMonth } from 'date-fns'

export async function maybeAutoGenerateDeploymentInvoice(params: {
  taskId: number
  toStatus: string
}): Promise<void> {
  const { taskId, toStatus } = params

  // Only fire on deployment completion
  if (toStatus !== 'deployed') return

  // Fetch task with category + client
  const task = await prisma.clientTask.findUnique({
    where: { id: taskId },
    select: {
      id: true,
      category: true,
      clientId: true,
      client: {
        select: {
          id: true,
          businessName: true,
          status: true,
          retainerAmount: true,
          paymentTermsDays: true,
          waveCustomerId: true,
        },
      },
    },
  })

  if (!task || task.category !== 'website_deployment') return

  const client = task.client
  if (!client) return

  // Only bill active clients
  if (!['active', 'signed'].includes(client.status)) {
    console.log(`[invoice-hook] Skipping — client ${client.businessName} status="${client.status}"`)
    return
  }

  // Idempotency: check if an invoice was already created for this task
  const existing = await prisma.invoiceRecord.findFirst({
    where: { clientId: client.id, sourceTaskId: taskId },
  })
  if (existing) {
    console.log(`[invoice-hook] Invoice already exists for task ${taskId} — skipping`)
    return
  }

  // Resolve Wave product ID
  const seoProductId = await getSeoProductId()
  if (!seoProductId) {
    console.warn(`[invoice-hook] Wave SEO product not configured — deployment invoice skipped for task ${taskId}`)
    return
  }

  const waveCustomerId = await ensureWaveCustomer(client.id)

  const today = new Date()
  const invoiceDate = format(startOfMonth(today), 'yyyy-MM-dd')
  const dueDate = format(addDays(startOfMonth(today), client.paymentTermsDays ?? 30), 'yyyy-MM-dd')
  const amount = Number(client.retainerAmount)

  const waveInvoice = await createInvoice({
    waveCustomerId,
    invoiceDate,
    dueDate,
    memo: `Website Deployment — ${client.businessName}`,
    lineItems: [{
      productId: seoProductId,
      description: `Website Deployment — ${client.businessName}`,
      quantity: 1,
      unitPrice: amount,
    }],
  })

  const record = await prisma.invoiceRecord.create({
    data: {
      clientId: client.id,
      sourceTaskId: taskId,
      waveInvoiceId: waveInvoice.id,
      invoiceNumber: waveInvoice.invoiceNumber,
      amount: client.retainerAmount,
      status: 'draft',
      issuedDate: new Date(invoiceDate),
      dueDate: new Date(dueDate),
      waveViewUrl: waveInvoice.viewUrl,
      lineItems: [{
        description: `Website Deployment — ${client.businessName}`,
        quantity: 1,
        unitPrice: amount,
      }],
    },
  })

  const sent = await sendInvoice(waveInvoice.id)
  if (sent) {
    await prisma.invoiceRecord.update({ where: { id: record.id }, data: { status: 'sent' } })
    await prisma.clientProfile.update({ where: { id: client.id }, data: { lastInvoiceDate: new Date() } })
  }

  console.log(`[invoice-hook] Invoice ${waveInvoice.invoiceNumber} created + ${sent ? 'sent' : 'draft'} for task ${taskId} (${client.businessName})`)
}
